import { createClient } from "npm:@supabase/supabase-js@2";
import { ethers } from "npm:ethers@6";

function mustEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env: ${name}`);
  return v;
}

Deno.serve(async (req) => {
  try {
    const supabaseAdmin = createClient(
      mustEnv("SUPABASE_URL"),
      mustEnv("SUPABASE_SERVICE_ROLE_KEY")
    );

    // Get user from the caller JWT
    const authHeader = req.headers.get("authorization") || "";
    const jwt = authHeader.startsWith("Bearer ") ? authHeader.slice(7) : null;
    if (!jwt) return new Response(JSON.stringify({ error: "missing_jwt" }), { status: 401 });

    const { data: u, error: uErr } = await supabaseAdmin.auth.getUser(jwt);
    if (uErr || !u?.user?.id) {
      return new Response(JSON.stringify({ error: "invalid_user" }), { status: 401 });
    }
    const userId = u.user.id;

    // If address already exists, return it
    const { data: existing, error: exErr } = await supabaseAdmin
      .from("deposit_addresses")
      .select("address, derivation_path")
      .eq("user_id", userId)
      .eq("chain", "BSC")
      .eq("status", "active")
      .maybeSingle();

    if (exErr) throw exErr;
    if (existing?.address) {
      return new Response(JSON.stringify({ address: existing.address, derivation_path: existing.derivation_path }), {
        status: 200,
        headers: { "Content-Type": "application/json" },
      });
    }

    // Allocate stable derivation index for this user
    const { data: idxRow, error: idxErr } = await supabaseAdmin
      .from("user_deposit_index")
      .select("derivation_index")
      .eq("user_id", userId)
      .eq("chain", "BSC")
      .maybeSingle();

    if (idxErr) throw idxErr;

    let derivationIndex: number;

    if (idxRow?.derivation_index !== undefined && idxRow?.derivation_index !== null) {
      derivationIndex = Number(idxRow.derivation_index);
    } else {
      // get next index from sequence
      const { data: seq, error: seqErr } = await supabaseAdmin.rpc("next_deposit_derivation_index");
      if (seqErr) throw seqErr;

      derivationIndex = Number(seq);

      const { error: insIdxErr } = await supabaseAdmin
        .from("user_deposit_index")
        .insert([{ user_id: userId, chain: "BSC", derivation_index: derivationIndex }]);
      if (insIdxErr) throw insIdxErr;
    }

    // Derive address from MASTER_MNEMONIC
    const mnemonic = ethers.Mnemonic.fromPhrase(mustEnv("MASTER_MNEMONIC").trim());
    const derivationPath = `m/44'/60'/0'/0/${derivationIndex}`;
    const wallet = ethers.HDNodeWallet.fromMnemonic(mnemonic, derivationPath);

    const address = wallet.address;

    // Save address
    const { error: insAddrErr } = await supabaseAdmin
      .from("deposit_addresses")
      .insert([{
        user_id: userId,
        chain: "BSC",
        address,
        derivation_path: derivationPath,
        status: "active",
      }]);

    if (insAddrErr) throw insAddrErr;

    return new Response(JSON.stringify({ address, derivation_path: derivationPath }), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });

  } catch (e) {
    return new Response(JSON.stringify({ error: "runtime_error", message: String((e as any)?.message || e) }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
});
